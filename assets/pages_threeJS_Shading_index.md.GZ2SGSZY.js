import{_ as s,c as i,o as a,V as n}from"./chunks/framework.V-t2EA2A.js";const t="/3d-summary-notes/assets/Blinn-Phong._ATIeRjE.png",l="/3d-summary-notes/assets/Diffuse.B114fnLB.png",e="/3d-summary-notes/assets/phong.iboHa3RA.png",p="/3d-summary-notes/assets/half.hHg_h8-s.png",h="/3d-summary-notes/assets/Specular.k5706xo9.png",r="/3d-summary-notes/assets/formula.lN611TtA.png",k="/3d-summary-notes/assets/frequency.dYKpfWM7.png",o="/3d-summary-notes/assets/centroid.wJWsuCSv.png",c="/3d-summary-notes/assets/effect.B0wPMBCC.png",d="/3d-summary-notes/assets/small.C5nEUQg2.png",g="/3d-summary-notes/assets/Bilinear.OIafq8Yz.png",m="/3d-summary-notes/assets/big.3xRNjGiF.png",u="/3d-summary-notes/assets/mipmap.RYWYRjea.png",E="/3d-summary-notes/assets/level.aw80HHS_.png",y="/3d-summary-notes/assets/before.rNRKf7cQ.png",f="/3d-summary-notes/assets/Trilinear.ubXEICbc.png",b="/3d-summary-notes/assets/after.sTgHbisM.png",_="/3d-summary-notes/assets/ripmap.IXE-sAbN.png",F="/3d-summary-notes/assets/EWA.86_FAxB0.png",R=JSON.parse('{"title":"着色（Shading）","description":"","frontmatter":{},"headers":[],"relativePath":"pages/threeJS/Shading/index.md","filePath":"pages/threeJS/Shading/index.md"}'),q={name:"pages/threeJS/Shading/index.md"},A=n('<h1 id="着色-shading" tabindex="-1">着色（Shading） <a class="header-anchor" href="#着色-shading" aria-label="Permalink to &quot;着色（Shading）&quot;">​</a></h1><h2 id="光照模型计算" tabindex="-1">光照模型计算 <a class="header-anchor" href="#光照模型计算" aria-label="Permalink to &quot;光照模型计算&quot;">​</a></h2><blockquote><p>在光照模型计算中，可以考虑光源的类型（如点光源、方向光源、环境光等）以及材质属性（如漫反射、镜面反射、环境反射等）。根据像素的位置、法线方向和光照参数，计算像素的漫反射和镜面反射颜色，以模拟光照效果。</p></blockquote><h3 id="blinn-phong-模型" tabindex="-1">Blinn-Phong 模型 <a class="header-anchor" href="#blinn-phong-模型" aria-label="Permalink to &quot;Blinn-Phong 模型&quot;">​</a></h3><blockquote><p>Blinn-Phong 模型包含三部分：漫反射（Diffuse reflection） + 镜面反射（Specular highlights） + 环境光反射（Ambient lighting）</p></blockquote><p><img src="'+t+'" alt="Blinn-Phong"></p><h4 id="漫反射-diffuse-reflection" tabindex="-1">漫反射（Diffuse reflection） <a class="header-anchor" href="#漫反射-diffuse-reflection" aria-label="Permalink to &quot;漫反射（Diffuse reflection）&quot;">​</a></h4><p><img src="'+l+'" alt="Diffuse"></p><p>$$L_d = k_d \\cdot (I/r^2) \\cdot \\max(0, \\mathbf{n} \\cdot \\mathbf{l})$$</p><h4 id="镜面反射-specular-highlights" tabindex="-1">镜面反射（Specular highlights） <a class="header-anchor" href="#镜面反射-specular-highlights" aria-label="Permalink to &quot;镜面反射（Specular highlights）&quot;">​</a></h4><ul><li>Phong 模型中的 v 和 R</li></ul><p><img src="'+e+'" alt="phong"></p><ul><li>半程向量</li></ul><p><img src="'+p+'" alt="half"></p><p>$$L_s = k_s \\cdot (I/r^2) \\cdot (\\max(0, \\mathbf{n} \\cdot \\mathbf{h}))^p$$</p><p><img src="'+h+'" alt="Specular"></p><h4 id="环境光反射-ambient-lighting" tabindex="-1">环境光反射（Ambient lighting） <a class="header-anchor" href="#环境光反射-ambient-lighting" aria-label="Permalink to &quot;环境光反射（Ambient lighting）&quot;">​</a></h4><p>$$L_a = k_a \\cdot I_a$$</p><p>其中，$$k_a$$ 是环境光系数，$$I_a$$ 是环境光照强度。</p><h4 id="blinn-phong-模型公式" tabindex="-1">Blinn-Phong 模型公式 <a class="header-anchor" href="#blinn-phong-模型公式" aria-label="Permalink to &quot;Blinn-Phong 模型公式&quot;">​</a></h4><p><img src="'+r+'" alt="formula"></p><p>$$L = L_a + L_d + L_s = k_a \\cdot I_a + k_d \\cdot (I/r^2) \\cdot (\\mathbf{n} \\cdot \\mathbf{l}) + k_s \\cdot (I/r^2) \\cdot (\\max(0, \\mathbf{n} \\cdot \\mathbf{h}))^p$$</p><h3 id="着色频率" tabindex="-1">着色频率 <a class="header-anchor" href="#着色频率" aria-label="Permalink to &quot;着色频率&quot;">​</a></h3><blockquote><p>着色频率有三种：每个三角面着色、每个顶点着色、每个像素着色。</p></blockquote><blockquote><p>上面的 Blinn-Phong 模型针对的是物体表面一个单一的点，模型中的法向量很重要，不同的着色频率法向量的计算难度也不同：</p></blockquote><ul><li><p>三角面的法向量：$$\\vec {AB} \\cdot \\vec {AC}$$</p></li><li><p>顶点的法向量：与该顶点相连的多个三角面法向量加权平均</p></li><li><p>像素的法向量：通过对几何体的法向量进行插值，重⼼坐标插值（Barycentric Interpolation）</p></li></ul><p><img src="'+k+'" alt="frequency"></p><h3 id="重心坐标-barycentric-coordinates" tabindex="-1">重⼼坐标（Barycentric Coordinates） <a class="header-anchor" href="#重心坐标-barycentric-coordinates" aria-label="Permalink to &quot;重⼼坐标（Barycentric Coordinates）&quot;">​</a></h3><ul><li><p>重心坐标必须满足两个条件：</p><ul><li><p>重心坐标的值为非负数：u ≥ 0，v ≥ 0，w ≥ 0。</p></li><li><p>重心坐标的值之和为 1：u + v + w = 1。</p></li></ul></li><li><p>插值的时候，u v w 都取 1/3</p></li></ul><p><img src="'+o+'" alt="centroid"></p><ul><li>插值效果</li></ul><p><img src="'+c+'" alt="effect"></p><h4 id="重心坐标的应用" tabindex="-1">重⼼坐标的应用 <a class="header-anchor" href="#重心坐标的应用" aria-label="Permalink to &quot;重⼼坐标的应用&quot;">​</a></h4><ul><li><p>颜色插值和混合：如果像素的颜色是通过顶点着色插值得到的，片元着色阶段可以对这些颜色进行插值操作，以得到像素的最终颜色。此外，还可以进行颜色的混合操作，如透明度混合、颜色混合和阴影混合等。</p></li><li><p>法线插值和变换：对于法线映射和光照计算，片元着色阶段可以进行法线向量的插值操作，以在像素级别上模拟物体表面的细节。此外，还可以对法线进行变换，以适应不同的坐标系或局部坐标空间。</p></li></ul><h2 id="纹理映射" tabindex="-1">纹理映射 <a class="header-anchor" href="#纹理映射" aria-label="Permalink to &quot;纹理映射&quot;">​</a></h2><blockquote><p>如果应用了纹理映射，片元着色阶段将进行纹理坐标的插值和采样操作。根据纹理坐标，在纹理图像中查找对应的颜色值，并将其应用到像素上。这允许在表面上显示出纹理、图案或图像。</p></blockquote><blockquote><p>纹理映射的问题：纹理太小，锯齿；纹理太大，摩尔纹、锯齿、过度模糊；</p></blockquote><h3 id="纹理太小问题" tabindex="-1">纹理太小问题 <a class="header-anchor" href="#纹理太小问题" aria-label="Permalink to &quot;纹理太小问题&quot;">​</a></h3><blockquote><p>Texture Magnification：texture is too small</p></blockquote><ul><li>效果图</li></ul><p><img src="'+d+'" alt="small"></p><ul><li><p>Nearest 插值：就近取值</p></li><li><p>Bilinear 插值：就近4个点双线性插值</p><p><img src="'+g+'" alt="Bilinear"></p></li><li><p>Bicubic 插值：就近16个点插值</p></li></ul><h3 id="纹理太大问题" tabindex="-1">纹理太大问题 <a class="header-anchor" href="#纹理太大问题" aria-label="Permalink to &quot;纹理太大问题&quot;">​</a></h3><blockquote><p>Texture Magnification：texture is too large</p></blockquote><ul><li>效果图</li></ul><p><img src="'+m+'" alt="big"></p><ul><li><p>问题分析：本质就是采样问题，超采样可以解决问题，但是开销太大，更好的解决方案是：直接不采样，将采样的点查询换成范围查询。</p></li><li><p>Mipmaps：正方形范围查询</p><ul><li>Mipmaps 图</li></ul><p><img src="'+u+'" alt="mipmap"></p><ul><li>Mipmaps 层级计算</li></ul><p><img src="'+E+'" alt="level"></p><ul><li>Mipmaps 层级就近取整效果图</li></ul><p><img src="'+y+'" alt="before"></p><ul><li>Mipmaps 不同层级之间的 Trilinear 插值计算过程</li></ul><p><img src="'+f+'" alt="Trilinear"></p><ul><li>Mipmaps 层级 Trilinear 插值效果图</li></ul><p><img src="'+b+'" alt="after"></p></li><li><p>Ripmaps：矩形范围查询</p></li></ul><blockquote><p>Anisotropic Filtering: 各向异性过滤</p></blockquote><p><img src="'+_+'" alt="ripmap"></p><ul><li>EWA：不规则图形范围查询</li></ul><blockquote><p>EWA Filtering: 椭圆加权平均过滤</p></blockquote><p><img src="'+F+`" alt="EWA"></p><h2 id="后期处理和特效" tabindex="-1">后期处理和特效 <a class="header-anchor" href="#后期处理和特效" aria-label="Permalink to &quot;后期处理和特效&quot;">​</a></h2><blockquote><p>片元着色阶段还可以应用各种后期处理技术和特效，如景深效果、运动模糊、辉光、色彩校正等。这些技术可以在最后的渲染阶段对像素进行进一步的处理，以增强图像的质量和艺术效果</p></blockquote><h3 id="three-js-的后期处理代码示例" tabindex="-1">THREE.JS 的后期处理代码示例 <a class="header-anchor" href="#three-js-的后期处理代码示例" aria-label="Permalink to &quot;THREE.JS 的后期处理代码示例&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> THREE </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;three&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 导入后期效果合成器</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { EffectComposer } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;three/examples/jsm/postprocessing/EffectComposer&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// three框架本身自带效果</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { RenderPass } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;three/examples/jsm/postprocessing/RenderPass&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { GlitchPass } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;three/examples/jsm/postprocessing/GlitchPass&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 合成效果</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> effectComposer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EffectComposer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(renderer)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">effectComposer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window.innerWidth, window.innerHeight)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 添加渲染通道</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> renderPass</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RenderPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(scene, camera)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">effectComposer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(renderPass)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 屏幕闪动</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> glitchPass</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GlitchPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">effectComposer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(glitchPass)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> clock</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> THREE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Clock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> animate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> elapsedTime</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElapsedTime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  rawShaderMaterial.uniforms.uTime.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> elapsedTime</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  animationID </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> requestAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(animate)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  renderer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> renderer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(scene, camera)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  effectComposer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">animate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div>`,56),C=[A];function B(D,P,x,$,S,T){return a(),i("div",null,C)}const w=s(q,[["render",B]]);export{R as __pageData,w as default};
