import{_ as e,c as a,o,V as t}from"./chunks/framework.V-t2EA2A.js";const b=JSON.parse('{"title":"shader","description":"","frontmatter":{},"headers":[],"relativePath":"pages/shader/index.md","filePath":"pages/shader/index.md"}'),s={name:"pages/shader/index.md"},r=t('<h1 id="shader" tabindex="-1">shader <a class="header-anchor" href="#shader" aria-label="Permalink to &quot;shader&quot;">​</a></h1><h2 id="glsl是什么" tabindex="-1">GLSL是什么？ <a class="header-anchor" href="#glsl是什么" aria-label="Permalink to &quot;GLSL是什么？&quot;">​</a></h2><blockquote><p>GLSL 代表 openGL Shading Language，openGL 着色语言。根据硬件和操作系统的不同，还有其他的着色器（shaders)。</p></blockquote><h2 id="为什么-shaders-运行特别快" tabindex="-1">为什么 shaders 运行特别快? <a class="header-anchor" href="#为什么-shaders-运行特别快" aria-label="Permalink to &quot;为什么 shaders 运行特别快?&quot;">​</a></h2><blockquote><p>并行处理: 比起用三五个强大的微处理器（或者说“管道”）来处理图形信息，用一大堆小的微处理器来并行计算，就要好得多。这就是图形处理器（GPU : Graphic Processor Unit)的来由。</p></blockquote><blockquote><p>内置数学函数: GPU 的魔法是特殊数学函数可通过硬件加速。非常复杂的数学操作可以直接被微芯片解决，而无须通过软件。这就表示可以有更快的三角和矩阵运算 —— 和电流一样快。</p></blockquote><blockquote><p>图形引擎：Metal(苹果)、DirectX(微软)、Vulkan(跨平台)。</p></blockquote><h2 id="为什么-shaders-不好学" tabindex="-1">为什么 Shaders 不好学？ <a class="header-anchor" href="#为什么-shaders-不好学" aria-label="Permalink to &quot;为什么 Shaders 不好学？&quot;">​</a></h2><blockquote><p>并行计算: 为了能使许多管线并行运行，每一个线程必须与其他的相独立。我们称这些线程对于其他线程在进行的运算是“盲视”的。这个限制就会使得所有数据必须以相同的方向流动。所以就不可能检查其他线程的输出结果，修改输入的数据，或者把一个线程的输出结果输入给另一个线程。允许数据在线程之间线程流动会使数据的整体性面临威胁。</p></blockquote><blockquote><p>GPU 会让所有并行的微处理器（管道们）一直处在忙碌状态；只要它们一有空闲就会接到新的信息。一个线程不可能知道它前一刻在做什么。它可能是在画操作系统界面上的一个按钮，然后渲染了游戏中的一部分天空，然后显示了一封 email 中的一些文字。每个线程不仅是“盲视”的，而且还是“无记忆”的。同时，它要求编写一个通用的规则，依据像素的不同位置依次输出不同的结果。这种抽象性，和盲视、无记忆的限制使得 shaders 在程序员新手中不是很受欢迎。</p></blockquote>',10),d=[r];function h(l,c,n,i,p,u){return o(),a("div",null,d)}const q=e(s,[["render",h]]);export{b as __pageData,q as default};
