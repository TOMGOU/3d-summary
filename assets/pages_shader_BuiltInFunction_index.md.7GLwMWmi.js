import{_ as t,c as d,o as e,V as a}from"./chunks/framework.V-t2EA2A.js";const u=JSON.parse('{"title":"shader","description":"","frontmatter":{},"headers":[],"relativePath":"pages/shader/BuiltInFunction/index.md","filePath":"pages/shader/BuiltInFunction/index.md"}'),r={name:"pages/shader/BuiltInFunction/index.md"},l=a('<h1 id="shader" tabindex="-1">shader <a class="header-anchor" href="#shader" aria-label="Permalink to &quot;shader&quot;">​</a></h1><h2 id="glsl-内置函数" tabindex="-1">glsl 内置函数 <a class="header-anchor" href="#glsl-内置函数" aria-label="Permalink to &quot;glsl 内置函数&quot;">​</a></h2><blockquote><p>官网文档地址：<a href="https://shaderific.com/glsl.html" target="_blank" rel="noreferrer">https://shaderific.com/glsl.html</a></p></blockquote><h3 id="_1-三角函数" tabindex="-1">1. 三角函数 <a class="header-anchor" href="#_1-三角函数" aria-label="Permalink to &quot;1. 三角函数&quot;">​</a></h3><blockquote><p>这类主要是和角度相关的函数</p></blockquote><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>sin(x)</td><td>正弦函数</td></tr><tr><td>cos(x)</td><td>余弦函数</td></tr><tr><td>tan(x)</td><td>正切函数</td></tr><tr><td>asin(x)</td><td>反正弦函数</td></tr><tr><td>acos(x)</td><td>反余弦函数</td></tr><tr><td>atan(x)</td><td>反正切函数</td></tr><tr><td>acot(x)</td><td>反余切函数</td></tr><tr><td>radians(x)</td><td>角度转换为弧度</td></tr><tr><td>degrees(x)</td><td>弧度转换为角度</td></tr></tbody></table><h3 id="_2-数学函数" tabindex="-1">2. 数学函数 <a class="header-anchor" href="#_2-数学函数" aria-label="Permalink to &quot;2. 数学函数&quot;">​</a></h3><blockquote><p>这类主要是对指数对数幂函数的操作</p></blockquote><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>pow(x,y)</td><td>x的y次方。如果x小于0，结果是未定义的。同样，如果x=0并且y&lt;=0,结果也是未定义的。</td></tr><tr><td>exp(x)</td><td>e的x次方</td></tr><tr><td>log(x)</td><td>计算满足x等于e的y次方的y的值。如果x的值小于0，结果是未定义的。</td></tr><tr><td>exp2(x)</td><td>exp2(x) 计算2的x次方</td></tr><tr><td>log2(x)</td><td>计算满足x等于2的y次方的y的值。如果x的值小于0，结果是未定义的。</td></tr><tr><td>sqrt(x)</td><td>计算x的开方。如果x小于0，结果是未定义的。</td></tr><tr><td>inversesqrt(x)</td><td>计算x的开方之一的值，如果x小于等于0，结果是未定义的。</td></tr></tbody></table><h3 id="_3-常用函数" tabindex="-1">3. 常用函数 <a class="header-anchor" href="#_3-常用函数" aria-label="Permalink to &quot;3. 常用函数&quot;">​</a></h3><blockquote><p>常用函数，和js中的内置函数很像，必须掌握</p></blockquote><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>abs(x)</td><td>返回x的绝对值</td></tr><tr><td>sign(x)</td><td>如果x&gt;0，返回1.0；如果x=0，返回0，如果x&lt;0，返回-1.0</td></tr><tr><td>floor(x)</td><td>返回小于等于x的最大整数值</td></tr><tr><td>ceil(x)</td><td>返回大于等于x的最小整数值</td></tr><tr><td>fract(x)</td><td>返回x-floor(x)，即返回x的小数部分</td></tr><tr><td>mod(x, y)</td><td>返回x和y的模</td></tr><tr><td>min(x, y)</td><td>返回x和y的值较小的那个值</td></tr><tr><td>max(x, y)</td><td>返回x和y的值较大的那个值</td></tr><tr><td>clamp(x, minVal, maxVal)</td><td>将x值钳于minVal和maxVal之间，意思就是当x<code>&lt;</code>minVal时返回minVal，当x<code>&gt;</code>maxVal时返回maxVal，当x在minVal和maxVal之间时，返回x</td></tr><tr><td>mix(x, y, a)</td><td>返回线性混合的x和y，如：x*(1−a)+y*a</td></tr><tr><td>step(edge, x)</td><td>step(edge, x) 如果x &lt; edge，返回0.0，否则返回1.0</td></tr><tr><td>smoothstep(edge0, edge1, x)</td><td>如果x &lt;= edge0，返回0.0 ；如果x &gt;= edge1 返回1.0；如果edge0 &lt; x &lt; edge1，则执行0~1之间的平滑埃尔米特差值。如果edge0 &gt;= edge1，结果是未定义的。</td></tr></tbody></table><h3 id="_4-几何函数" tabindex="-1">4. 几何函数 <a class="header-anchor" href="#_4-几何函数" aria-label="Permalink to &quot;4. 几何函数&quot;">​</a></h3><blockquote><p>这类主要是与长度、距离、向量等相关的函数</p></blockquote><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>length(x)</td><td>返回向量x的长度</td></tr><tr><td>distance(p0,p1)</td><td>计算向量p0，p1之间的距离</td></tr><tr><td>dot</td><td>向量x，y之间的点积</td></tr><tr><td>cross(x, y)</td><td>向量x，y之间的叉积</td></tr><tr><td>normalize(x)</td><td>标准化向量，返回一个方向和x相同但长度为1的向量</td></tr><tr><td>faceforward(N, I, Nref)</td><td>如果Nref和I的点积小于0，返回N；否则，返回-N；</td></tr><tr><td>reflect(I, N)</td><td>返回反射向量</td></tr><tr><td>refract(I, N, eta)</td><td>返回折射向量</td></tr></tbody></table><h3 id="_5-矩阵函数" tabindex="-1">5. 矩阵函数 <a class="header-anchor" href="#_5-矩阵函数" aria-label="Permalink to &quot;5. 矩阵函数&quot;">​</a></h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>matrixCompMult(A, B)</td><td>逐元素乘法</td></tr></tbody></table><h3 id="_6-向量函数" tabindex="-1">6. 向量函数 <a class="header-anchor" href="#_6-向量函数" aria-label="Permalink to &quot;6. 向量函数&quot;">​</a></h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>lessThan(a, b)</td><td>$$\\vec a$$ 与 $$\\vec b$$ 逐元素小于</td></tr><tr><td>lessThanEqual(a, b)</td><td>$$\\vec a$$ 与 $$\\vec b$$ 逐元素小于等于</td></tr><tr><td>greaterThan(a, b)</td><td>$$\\vec a$$ 与 $$\\vec b$$ 逐元素大于</td></tr><tr><td>greaterThanEqual(a, b)</td><td>$$\\vec a$$ 与 $$\\vec b$$ 逐元素大于等于</td></tr><tr><td>equal(a, b)</td><td>$$\\vec a$$ 与 $$\\vec b$$ 逐元素相等</td></tr><tr><td>notEqual(a, b)</td><td>$$\\vec a$$ 与 $$\\vec b$$ 逐元素不等于</td></tr><tr><td>any(a)</td><td>$$\\vec a$$ 任一元素为true，则为true</td></tr><tr><td>all(a)</td><td>$$\\vec a$$ 所有元素为true 则为true</td></tr><tr><td>not(a)</td><td>$$\\vec a$$ 逐元素取补</td></tr></tbody></table><h3 id="_7-纹理函数" tabindex="-1">7. 纹理函数 <a class="header-anchor" href="#_7-纹理函数" aria-label="Permalink to &quot;7. 纹理函数&quot;">​</a></h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>texture2D(texture, uv)</td><td>在二维纹理(texture)中按照 uv 坐标获取纹素</td></tr></tbody></table>',21),o=[l];function h(x,c,n,s,i,b){return e(),d("div",null,o)}const _=t(r,[["render",h]]);export{u as __pageData,_ as default};
