import{_ as i,c as e,o as l,V as a}from"./chunks/framework.dnpgIXFM.js";const f=JSON.parse('{"title":"shader","description":"","frontmatter":{},"headers":[],"relativePath":"pages/shader/Syntax/index.md","filePath":"pages/shader/Syntax/index.md"}'),t={name:"pages/shader/Syntax/index.md"},s=a(`<h1 id="shader" tabindex="-1">shader <a class="header-anchor" href="#shader" aria-label="Permalink to &quot;shader&quot;">​</a></h1><h2 id="glsl-语法" tabindex="-1">glsl 语法 <a class="header-anchor" href="#glsl-语法" aria-label="Permalink to &quot;glsl 语法&quot;">​</a></h2><h3 id="三种限定符-uniform-attribute-和-varying" tabindex="-1">三种限定符（uniform，attribute 和 varying） <a class="header-anchor" href="#三种限定符-uniform-attribute-和-varying" aria-label="Permalink to &quot;三种限定符（uniform，attribute 和 varying）&quot;">​</a></h3><ul><li><p><code>uniform</code>(一致变量)：外部程序传递给（vertex 和 fragment）shader 的变量，不能被 shader 程序修改。</p></li><li><p><code>attribute</code>(属性变量)：只能在vertex shader中使用的变量，一般用attribute变量来表示一些顶点的数据，如：顶点坐标，法线，纹理坐标，顶点颜色等。</p></li><li><p><code>varying</code>(易变变量)：vertex和fragment shader之间做数据传递用的。一般vertex shader修改varying变量的值，然后fragment shader使用该varying变量的值。因此varying变量在vertex和fragment shader二者之间的声明必须是一致的。</p></li></ul><h3 id="预处理命令" tabindex="-1">预处理命令 <a class="header-anchor" href="#预处理命令" aria-label="Permalink to &quot;预处理命令&quot;">​</a></h3><ul><li><p><code>#define</code>：宏定义，在编译处理阶段起作用。</p></li><li><p><code>#ifdef</code>：判断一个宏定义是否存在，如果存在，在编译预处理的时候，保留 #ifdef 和 #endif 两个关键字之间的代码。</p></li><li><p><code>#if</code>：判断条件是否成立，如果成立，在编译预处理后会保留通过 #if 和 #endif 两个关键字之间的代码，否在不保留。</p></li><li><p><code>#include</code>：引入另一个着色器文件，在编译预处理后替换。</p></li></ul><h3 id="变量类型" tabindex="-1">变量类型 <a class="header-anchor" href="#变量类型" aria-label="Permalink to &quot;变量类型&quot;">​</a></h3><ul><li><p>标量</p><ul><li>float: 浮点数</li><li>int: 整数</li><li>unit: 无符号整数</li><li>bool: 布尔值</li></ul></li><li><p>矢量</p><ul><li>vec3: 包含3个浮点数的矢量</li><li>ivec3: 包含3个整数的矢量</li><li>uvec3: 包含3个无符号整数的矢量</li><li>bvec3: 包含3个布尔值的矢量</li></ul></li><li><p>矩阵</p><ul><li>mat2: 2*2 的浮点数矩阵</li><li>mat3: 3*3 的浮点数矩阵</li><li>mat4: 4*4 的浮点数矩阵</li></ul></li><li><p>取样器</p><blockquote><p>纹理查找需要指定一个纹理或者纹理单元，GLSL不关心纹理单元的底层实现，因此它提供了 一个简单而不透明的句柄来封装需要查找的对象。这些句柄被称为&quot;取样器(SAMPLERS)&quot;。</p></blockquote><ul><li>sampler3D：访问三维纹理</li><li>samplerCube：访问立方贴图纹理</li><li>sampler2DRect：访问二维矩形纹理</li><li>sampler2DRectShadow：访问带对比的二维矩形深度纹理</li><li>sampler2DArrayShadow：访问二维深度纹理数组</li><li>samplerBuffer：访问纹理缓存</li><li>isampler3D：访问整型三维纹理</li><li>usampler3D：访问无符号整型三维纹理</li></ul></li><li><p>结构</p><blockquote><p>GLSL提供了类似于C 的用户定义结构。</p></blockquote><div class="language-glsl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> light {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  vec3 position;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  vec3 color;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>数组</p><blockquote><p>GLSL可以创建任何类型的数组。</p></blockquote><ul><li><p>创建的是一个包含 10 个 vec4 类型的数组：vec4 points[10];</p></li><li><p>创建的是一个位置大小的 int 类型的数组：int num[];</p></li></ul></li></ul>`,8),r=[s];function n(o,p,d,c,h,u){return l(),e("div",null,r)}const g=i(t,[["render",n]]);export{f as __pageData,g as default};
